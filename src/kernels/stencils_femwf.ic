extern real_t* recv_rec; //@KADIR array for receiver recording
extern size_t* irecv_rec; //@KADIR index into the recv_rec
extern size_t isrc_exc; //@KADIR number of source excitations performed so far
#include <math.h>
#include <omp.h>
void TEMPLATE(femwd,FUNC_NAME)( const int shape[3], const int xb, const int yb_r0, const int zb, const int xe, const int ye_r0, const int ze,
    const real_t * restrict coef, real_t * restrict u,
    real_t * restrict v, const real_t * restrict roc2, int t_dim, int b_inc, int e_inc, int NHALO, int tb, int te, stencil_CTX stencil_ctx, int mtid) {
      //@KADIR TODO ADD SOURCE AND RECEIVERS

#pragma omp parallel shared(shape, stencil_ctx, roc2, coef, mtid, tb, te, t_dim, NHALO, \
        recv_rec, irecv_rec\
        ) \
        firstprivate(u, v, b_inc, e_inc) \
        num_threads(stencil_ctx.thread_group_size) PROC_BIND(master)
  {
//    KA_SHOW(FUNC_NAME);
//    printf("%p\n",  TEMPLATE(femwd, FUNC_NAME));
    int tgs, nwf, th_nwf, tid, gtid, zi, yb, ye, ib, ie, kt, t, k, j, i, q, r, err; 
    double t_start;

    const int nny =shape[1];
    const int nnx =shape[0];
    const unsigned long nnxy = 1UL * nnx * nny;
    uint64_t  ln_domain = ((uint64_t) 1)* shape[0]*shape[1]*shape[2];

    tgs = stencil_ctx.thread_group_size;
    nwf = stencil_ctx.num_wf;

    tid = 0;
    gtid = 0;
#if defined(_OPENMP)
    tid = omp_get_thread_num();
    gtid = tid + mtid * tgs;
#endif

    if(stencil_ctx.use_manual_cpu_bind == 1){
      err = sched_setaffinity(0, stencil_ctx.setsize, stencil_ctx.bind_masks[mtid*tgs+tid]);
      if(err==-1) printf("WARNING: Could not set CPU Affinity\n");
    }

    real_t * restrict u_r = u;
    real_t * restrict v_r = v;
    real_t *restrict ux, *restrict vx;

    int th_x = stencil_ctx.th_x;
    int th_y = stencil_ctx.th_y;
    int th_z = stencil_ctx.th_z;

    // tid = tid_z*(th_x*th_y) + tid_y*th_x + tid_x
    int tid_x = tid%th_x;
    int tid_y = tid/th_x;
    int tid_z = tid/(th_x*th_y);

    int yb_r = yb_r0;
    int ye_r = ye_r0;

    if(stencil_ctx.th_y>1 ){
      if(b_inc !=0 && e_inc!=0){ // split only at full diamonds 
        if (tid_y%2 == 0){ // left thread
          ye_r = (yb_r + ye_r)/2;
          e_inc = 0;
        } else{
          yb_r = (yb_r + ye_r)/2;
          b_inc = 0;
        }
      }else{// use the y-threads along z-axis make sure to use sufficient number of frontlines
        th_z *= th_y;
        tid_z = tid/th_x;
        if (nwf < th_z) nwf = th_z;
      }
    }

    int nbx = (xe-xb)/th_x;
    q = (int)((xe-xb)/th_x);
    r = (xe-xb)%th_x;
    if(tid_x < r) {
      ib = xb + tid_x * (q+1);
      ie = ib + (q+1);
    }else {
      ib = xb + r * (q+1) + (tid_x - r) * q;
      ie = ib + q;
    }

    th_nwf = nwf/th_z;

    int printed = 0; //@KADIR

    for(zi=zb; zi<ze; zi+=nwf) { // wavefront loop (Z direction)

      if(ze-zi < nwf){ 
        nwf = ze-zi;
      }

      yb = yb_r;
      ye = ye_r;

      kt = zi;
      for(t=tb; t< te; t++){ // Diamond blocking in time
        real_t* output_buffer = NULL;  //@KADIR
        if(t%2 == 0){ //swap pointers
          u = v_r; v = u_r;
        } else{
          u = u_r; v = v_r;
        }
        output_buffer = u;      //@KADIR
        for(k=kt; k<kt+nwf; k++){

          if( ((k-NHALO)/th_nwf)%th_z == tid_z ) {
            for(j=yb; j<ye; j++) {
              ux = &(u[1ULL*k*nnxy + j*nnx]);
              vx = &(v[1ULL*k*nnxy + j*nnx]);
    #pragma simd
              for(i=ib; i<ie; i++) {
                  FUNC_BODY_DR();
/*
                  if( (gp->source_point_enabled==1) 
                          && (gp->lsource_pt[0] == i ) //@KADIR
                          && (gp->lsource_pt[1] == j ) //@KADIR 
                          && (gp->lsource_pt[2] == k ) //@KADIR 
                    ) 
                  {
                      output_buffer[((1ULL)*((gp->lsource_pt[2])*(gp->ldomain_shape[1])+( gp->lsource_pt[1]))*(gp->ldomain_shape[0])+(gp->lsource_pt[0]))] += gp->src_exc_coef[isrc_exc];//@KADIR
                      if(0)printf("DIA\tts:%d idxU:-- valU:%.4f src_exc_coef:%.4f coef:%g %g %g %g %g\ti(%d-%d) %d/%d\n", isrc_exc,  output_buffer[((1ULL)*((gp->lsource_pt[2])*(gp->ldomain_shape[1])+( gp->lsource_pt[1]))*(gp->ldomain_shape[0])+(gp->lsource_pt[0]))],  gp->src_exc_coef[isrc_exc], coef[0], coef[1], coef[2], coef[3], coef[4],
                              ib, ie, omp_get_thread_num(), omp_get_num_threads()
                            );
                      isrc_exc++;
                  }

                  {
                      int ir;
                      for(ir = 0; ir < gp->num_receivers; ir++) {
                          if( (gp->receiver_pt[ir][0] == i ) //@KADIR
                                  && (gp->receiver_pt[ir][1] == j ) //@KADIR 
                                  && (gp->receiver_pt[ir][2] == k)
                                  ) //@KADIR 
                          {
                              real_t val = output_buffer[((1ULL)*((gp->receiver_pt[ir][2])*(gp->ldomain_shape[1])+( gp->receiver_pt[ir][1]))*(gp->ldomain_shape[0])+(gp->receiver_pt[ir][0]))];
                              size_t timestep = irecv_rec[ir];
                              recv_rec[timestep*gp->num_receivers+ir] = val;
                              irecv_rec[ir]++;

                              if(0 && ( fabs(val) > 1e-7)) 
                              {
                                  printf("%lu\tDIA\treceiver :%d/%d at %d,%d,%d has value %g\n", 
                                          irecv_rec[ir]-1,
                                          ir, gp->num_receivers, 
                                          gp->receiver_pt[ir][0], gp->receiver_pt[ir][1], gp->receiver_pt[ir][2], val
                                        );
                              }
                          }
                      }
                  }
*/

              }
            }
            

                  if( (gp->source_point_enabled==1) 
                          && (gp->lsource_pt[0] >= ib ) //@KADIR
                          && (gp->lsource_pt[0] <  ie ) //@KADIR
                          && (gp->lsource_pt[1] >= yb ) //@KADIR 
                          && (gp->lsource_pt[1] <  ye ) //@KADIR 
                          && (gp->lsource_pt[2] == k ) //@KADIR 
                    ) 
                  {
                      output_buffer[((1ULL)*((gp->lsource_pt[2])*(gp->ldomain_shape[1])+( gp->lsource_pt[1]))*(gp->ldomain_shape[0])+(gp->lsource_pt[0]))] += gp->src_exc_coef[isrc_exc];//@KADIR
                      if(0)printf("DIA\tts:%d idxU:-- valU:%.4f src_exc_coef:%.4f coef:%g %g %g %g %g\ti(%d-%d) %d/%d\n", isrc_exc,  output_buffer[((1ULL)*((gp->lsource_pt[2])*(gp->ldomain_shape[1])+( gp->lsource_pt[1]))*(gp->ldomain_shape[0])+(gp->lsource_pt[0]))],  gp->src_exc_coef[isrc_exc], coef[0], coef[1], coef[2], coef[3], coef[4],
                              ib, ie, omp_get_thread_num(), omp_get_num_threads()
                            );
                      isrc_exc++;
                  }
                  {
                      int ir;
                      for(ir = 0; ir < gp->num_receivers; ir++) {
                          if(    
                                     (gp->receiver_pt[ir][0] >= ib ) //@KADIR
                                  && (gp->receiver_pt[ir][0] <  ie ) //@KADIR
                                  && (gp->receiver_pt[ir][1] >= yb ) //@KADIR 
                                  && (gp->receiver_pt[ir][1] <  ye ) //@KADIR 
                                  && (gp->receiver_pt[ir][2] == k )
                                  ) //@KADIR 
                          {
                              real_t val = output_buffer[((1ULL)*((gp->receiver_pt[ir][2])*(gp->ldomain_shape[1])+( gp->receiver_pt[ir][1]))*(gp->ldomain_shape[0])+(gp->receiver_pt[ir][0]))];
                              size_t timestep = irecv_rec[ir];
                              recv_rec[timestep*gp->num_receivers+ir] = val;
                              irecv_rec[ir]++;

                              if(0 && ( fabs(val) > 1e-7)) 
                              {
                                  printf("%lu\tDIA\treceiver :%d/%d at %d,%d,%d has value %g\n", 
                                          irecv_rec[ir]-1,
                                          ir, gp->num_receivers, 
                                          gp->receiver_pt[ir][0], gp->receiver_pt[ir][1], gp->receiver_pt[ir][2], val
                                        );
                              }
                          }
                      }
                  }



          }
        }


        // Update block size in Y
        if(t< t_dim){ // lower half of the diamond
          yb -= b_inc;
          ye += e_inc;
        }else{ // upper half of the diamond
          yb += b_inc;
          ye -= e_inc;
        }

        kt -= NHALO;

        t_start = MPI_Wtime();
#pragma omp barrier
        stencil_ctx.t_wait[gtid] += MPI_Wtime() - t_start;

      } // diamond blocking in time (time loop)
    } // wavefront loop
  } // parallel region
}
